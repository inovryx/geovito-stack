---
import MainLayout from '../../../layouts/MainLayout.astro';
import StateBanner from '../../../components/StateBanner.astro';
import { resolveTranslation } from '../../../lib/languageState';
import { getAtlasPlaces, getBlogPosts, type AtlasPlace } from '../../../lib/strapi';
import { DEFAULT_LANGUAGE, isSupportedLanguage, pathForLanguage, SUPPORTED_LANGUAGES } from '../../../lib/languages';
import { absoluteUrl, buildLanguageLinks, toAlternates } from '../../../lib/pageHelpers';
import { buildIndexableLanguagePathMap, resolveIndexGate } from '../../../lib/indexGate';
import { chooseSlugForLanguage } from '../../../lib/slugResolver';
import { resolveBlogPlaceRefs } from '../../../lib/mockRelations';
import { getUiMessages, translate } from '../../../lib/uiLanguage';

export async function getStaticPaths() {
  const places = await getAtlasPlaces();
  const paths: Array<{ params: { lang: string; placeSlug: string }; props: { placeId: string } }> = [];
  const seen = new Set<string>();

  for (const place of places) {
    for (const language of SUPPORTED_LANGUAGES) {
      const slug = chooseSlugForLanguage(place.translations, language, place.canonical_language);
      if (!slug) continue;
      const key = `${language}:${slug}`;
      if (seen.has(key)) continue;
      seen.add(key);
      paths.push({
        params: { lang: language, placeSlug: slug },
        props: { placeId: place.place_id },
      });
    }
  }

  return paths;
}

const lang = Astro.params.lang || '';
if (!isSupportedLanguage(lang)) {
  throw new Error(`Unsupported language: ${lang}`);
}

const [allPlaces, allPosts] = await Promise.all([getAtlasPlaces(), getBlogPosts()]);
const place = allPlaces.find((entry) => entry.place_id === Astro.props.placeId) as AtlasPlace | undefined;
if (!place) {
  throw new Error(`Atlas place not found for place_id=${Astro.props.placeId}`);
}

const ui = getUiMessages(lang);
const runtimeMode = Astro.url.searchParams.get('translate') === '1';
const placeMap = new Map(allPlaces.map((entry) => [entry.place_id, entry]));

const mapPlaceLink = (entry: AtlasPlace) => {
  const translated = resolveTranslation(entry.translations, lang, entry.canonical_language);
  const requested = translated.requested;
  const complete = translated.complete;
  const output = translated.output;
  const slug = requested?.status === 'complete' && requested.slug ? requested.slug : complete?.slug;

  if (!output || !slug) return null;

  return {
    place_id: entry.place_id,
    place_type: entry.place_type,
    title: output.title || entry.place_id,
    href: pathForLanguage(lang, `atlas/${slug}`),
    state: requested?.status || 'missing',
  };
};

const resolution = resolveTranslation(place.translations, lang, place.canonical_language, runtimeMode);

if (!resolution.output || !resolution.complete) {
  throw new Error(`No complete translation for ${place.place_id}`);
}

const title = resolution.output.seo?.metaTitle || resolution.output.title || place.place_id;
const description = resolution.output.seo?.metaDescription || resolution.output.excerpt || '';
const isMockView = place.mock === true;
const enComplete =
  place.translations.find((translation) => translation.language === DEFAULT_LANGUAGE && translation.status === 'complete') ||
  null;
const canonicalSource = enComplete || resolution.complete;
const canonicalLanguage = enComplete ? DEFAULT_LANGUAGE : place.canonical_language;
const canonicalSlug = canonicalSource?.slug || place.place_id;

const canonicalPath =
  canonicalSource?.canonical_path || pathForLanguage(canonicalLanguage, `atlas/${canonicalSlug}`);

const languagePathMap: Record<string, string> = {};
for (const language of SUPPORTED_LANGUAGES) {
  const slug = chooseSlugForLanguage(place.translations, language, place.canonical_language);
  if (slug) {
    languagePathMap[language] = pathForLanguage(language, `atlas/${slug}`);
  }
}

const languageLinks = buildLanguageLinks(languagePathMap);
const indexableLanguagePathMap = buildIndexableLanguagePathMap(place.translations, 'atlas', isMockView);
if (!isMockView && enComplete?.slug && !indexableLanguagePathMap[DEFAULT_LANGUAGE]) {
  indexableLanguagePathMap[DEFAULT_LANGUAGE] = canonicalPath;
}
const indexableLanguageLinks = Object.fromEntries(
  Object.entries(indexableLanguagePathMap).map(([language, urlPath]) => [language, absoluteUrl(urlPath)])
);
const alternates = toAlternates(indexableLanguageLinks);
const canonical = absoluteUrl(canonicalPath);
const indexGate = resolveIndexGate(isMockView, resolution, lang);
const robots = indexGate.robots;

const parentPlaceId = place.parent_place_id || place.parent?.place_id || null;
const parentPlace = parentPlaceId ? placeMap.get(parentPlaceId) || null : null;
const parentLink = parentPlace ? mapPlaceLink(parentPlace) : null;
const regionLabel = parentLink?.title || null;
const latitude = typeof place.lat === 'number' ? place.lat : typeof place.latitude === 'number' ? place.latitude : null;
const longitude = typeof place.lng === 'number' ? place.lng : typeof place.longitude === 'number' ? place.longitude : null;
const coordinatesLabel =
  latitude !== null && longitude !== null ? `${latitude.toFixed(5)}, ${longitude.toFixed(5)}` : null;

const childPlaces = allPlaces.filter(
  (entry) => (entry.parent_place_id || entry.parent?.place_id || null) === place.place_id
);
const childLinks = childPlaces
  .map((entry) => mapPlaceLink(entry))
  .filter(Boolean)
  .sort((a, b) => a.title.localeCompare(b.title));
const visibleChildLinks = childLinks.slice(0, 30);
const hiddenChildCount = Math.max(0, childLinks.length - visibleChildLinks.length);

const breadcrumbChain: AtlasPlace[] = [];
const breadcrumbSeen = new Set<string>();
let cursor: AtlasPlace | null = place;

while (cursor && !breadcrumbSeen.has(cursor.place_id)) {
  breadcrumbChain.push(cursor);
  breadcrumbSeen.add(cursor.place_id);
  const nextParentId = cursor.parent_place_id || cursor.parent?.place_id || null;
  cursor = nextParentId ? placeMap.get(nextParentId) || null : null;
}

breadcrumbChain.reverse();
const breadcrumbLinks = breadcrumbChain.map((entry) => mapPlaceLink(entry)).filter(Boolean);

const excludedRelated = new Set([
  place.place_id,
  parentLink?.place_id || null,
  ...childLinks.map((entry) => entry.place_id),
]);

const relatedLinks = allPlaces
  .filter((entry) => {
    if (excludedRelated.has(entry.place_id)) return false;
    if (entry.country_code !== place.country_code) return false;

    const entryParentId = entry.parent_place_id || entry.parent?.place_id || null;
    if (entryParentId && parentPlaceId && entryParentId === parentPlaceId) return true;
    return entry.place_type === place.place_type;
  })
  .map((entry) => mapPlaceLink(entry))
  .filter(Boolean)
  .slice(0, 12);

const relatedBlogLinks = allPosts
  .filter((post) => {
    if (!post.published_on) return false;
    const refs = resolveBlogPlaceRefs(post);
    if (refs.includes(place.place_id)) return true;
    if (!Array.isArray(post.related_places) || post.related_places.length === 0) return false;
    return post.related_places.some((item) => item.place_id === place.place_id);
  })
  .map((post) => {
    const resolved = resolveTranslation(post.translations, lang, post.canonical_language);
    const requested = resolved.requested;
    const complete = resolved.complete;
    if (!resolved.output || !complete?.slug) return null;

    const slug = requested?.status === 'complete' && requested.slug ? requested.slug : complete.slug;
    return {
      post_id: post.post_id,
      title: resolved.output.title || post.post_id,
      href: pathForLanguage(lang, `blog/${slug}`),
      status: requested?.status || 'missing',
      published_on: post.published_on,
    };
  })
  .filter(Boolean)
  .slice(0, 8);
---

<MainLayout
  title={title}
  description={description}
  canonical={canonical}
  robots={robots}
  currentLanguage={lang}
  languageLinks={languageLinks}
  alternates={alternates}
  ui={ui}
>
  {isMockView ? <StateBanner status="mock" language={lang} canonicalPath={canonical} ui={ui} /> : null}

  {
    resolution.isRuntime ? (
      <StateBanner status="runtime" language={lang} canonicalPath={canonical} ui={ui} />
    ) : resolution.isFallback ? (
      <StateBanner
        status="fallback"
        language={lang}
        canonicalPath={canonical}
        contentStatus={resolution.requested?.status || 'missing'}
        ui={ui}
      />
    ) : null
  }

  <section class="place-hero">
    <div class="place-hero-content">
      <p class="eyebrow">{place.place_type}</p>
      <h1>{resolution.output.title}</h1>
      <p class="hero-lead">{resolution.output.excerpt || translate(ui, 'atlas.noBody')}</p>
      <div class="chip-row">
        <span class="status-pill">{resolution.requested?.status || 'missing'}</span>
        <span class="status-pill">{place.country_code}</span>
      </div>
    </div>

    <aside class="card place-facts">
      <h2>{translate(ui, 'atlas.meta.placeId')}</h2>
      <dl class="fact-grid">
        <div>
          <dt>{translate(ui, 'atlas.meta.placeId')}</dt>
          <dd>{place.place_id}</dd>
        </div>
        <div>
          <dt>{translate(ui, 'atlas.meta.type')}</dt>
          <dd>{place.place_type}</dd>
        </div>
        <div>
          <dt>{translate(ui, 'atlas.meta.country')}</dt>
          <dd>{place.country_code}</dd>
        </div>
        <div>
          <dt>{translate(ui, 'atlas.meta.region')}</dt>
          <dd>{regionLabel || translate(ui, 'atlas.meta.notAvailable')}</dd>
        </div>
        <div>
          <dt>{translate(ui, 'atlas.meta.coordinates')}</dt>
          <dd>{coordinatesLabel || translate(ui, 'atlas.meta.notAvailable')}</dd>
        </div>
        <div>
          <dt>{translate(ui, 'atlas.meta.languageStatus')}</dt>
          <dd>{resolution.requested?.status || 'missing'}</dd>
        </div>
      </dl>
    </aside>
  </section>

  <nav class="card breadcrumb-card" aria-label={translate(ui, 'atlas.links.breadcrumb')}>
    <strong>{translate(ui, 'atlas.links.breadcrumb')}</strong>
    <ol class="place-breadcrumb">
      {
        breadcrumbLinks.map((entry, index) => (
          <li>
            {index === breadcrumbLinks.length - 1 ? <span>{entry.title}</span> : <a href={entry.href}>{entry.title}</a>}
          </li>
        ))
      }
    </ol>
  </nav>

  <div class="grid two feature-grid">
    <section class="card panel">
      <div class="panel-head">
        <h2>{translate(ui, 'atlas.links.parent')}</h2>
      </div>
      {
        parentLink ? (
          <p>
            <a href={parentLink.href}>{parentLink.title}</a>
            <span class="status-pill">{parentLink.state}</span>
          </p>
        ) : (
          <div class="empty-state">
            <p>{translate(ui, 'atlas.links.noParent')}</p>
          </div>
        )
      }
    </section>

    <section class="card panel">
      <div class="panel-head">
        <h2>{translate(ui, 'atlas.links.children')}</h2>
      </div>
      {
        visibleChildLinks.length ? (
          <ul class="place-link-list">
            {visibleChildLinks.map((entry) => (
              <li>
                <a href={entry.href}>{entry.title}</a>
                <span class="status-pill">{entry.state}</span>
              </li>
            ))}
          </ul>
        ) : (
          <div class="empty-state">
            <p>{translate(ui, 'atlas.links.noChildren')}</p>
          </div>
        )
      }
      {hiddenChildCount > 0 ? <p class="small">+{hiddenChildCount} more children</p> : null}
    </section>
  </div>

  <div class="grid two feature-grid">
    <section class="card panel">
      <div class="panel-head">
        <h2>{translate(ui, 'atlas.links.related')}</h2>
      </div>
      {
        relatedLinks.length ? (
          <ul class="place-link-list">
            {relatedLinks.map((entry) => (
              <li>
                <a href={entry.href}>{entry.title}</a>
                <span class="status-pill">{entry.state}</span>
              </li>
            ))}
          </ul>
        ) : (
          <div class="empty-state">
            <p>{translate(ui, 'atlas.links.noRelated')}</p>
          </div>
        )
      }
    </section>

    <section class="card panel">
      <div class="panel-head">
        <h2>{translate(ui, 'atlas.links.relatedBlog')}</h2>
      </div>
      {
        relatedBlogLinks.length ? (
          <ul class="place-link-list">
            {relatedBlogLinks.map((entry) => (
              <li>
                <a href={entry.href}>{entry.title}</a>
                <span class="status-pill">{entry.status}</span>
                <span class="small">{entry.published_on}</span>
              </li>
            ))}
          </ul>
        ) : (
          <div class="empty-state">
            <p>{translate(ui, 'atlas.links.noRelatedBlog')}</p>
          </div>
        )
      }
    </section>
  </div>

  <section class="card prose-card">
    {resolution.output.body ? <article class="prose-body" set:html={resolution.output.body}></article> : <p>{translate(ui, 'atlas.noBody')}</p>}

    {
      resolution.requested?.status !== 'complete' && !runtimeMode ? (
        <p>
          <a href={`?translate=1`}>{translate(ui, 'actions.previewOnDemand')}</a>
        </p>
      ) : null
    }
  </section>
</MainLayout>
