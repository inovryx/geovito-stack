---
import MainLayout from '../../../layouts/MainLayout.astro';
import StateBanner from '../../../components/StateBanner.astro';
import AdSlot from '../../../components/ads/AdSlot.astro';
import PlaceHeader from '../../../components/atlas/PlaceHeader.astro';
import QuickFacts from '../../../components/atlas/QuickFacts.astro';
import HierarchyNav from '../../../components/atlas/HierarchyNav.astro';
import MiniTOC from '../../../components/atlas/MiniTOC.astro';
import RelatedPosts from '../../../components/atlas/RelatedPosts.astro';
import TravelEssentials from '../../../components/atlas/TravelEssentials.astro';
import Badge from '../../../components/ui/Badge.astro';
import BadgeGroup from '../../../components/ui/BadgeGroup.astro';
import Card from '../../../components/ui/Card.astro';
import EmptyState from '../../../components/ui/EmptyState.astro';
import { resolveTranslation } from '../../../lib/languageState';
import { getAtlasPlaces, getBlogPosts, type AtlasPlace } from '../../../lib/strapi';
import { DEFAULT_LANGUAGE, isSupportedLanguage, pathForLanguage, SUPPORTED_LANGUAGES } from '../../../lib/languages';
import { absoluteUrl, buildLanguageLinks, toAlternates } from '../../../lib/pageHelpers';
import { buildIndexableLanguagePathMap, resolveIndexGate } from '../../../lib/indexGate';
import { chooseSlugForLanguage } from '../../../lib/slugResolver';
import { resolveBlogPlaceRefs } from '../../../lib/mockRelations';
import { getUiMessages, translate } from '../../../lib/uiLanguage';

export async function getStaticPaths() {
  const places = await getAtlasPlaces();
  const paths: Array<{ params: { lang: string; placeSlug: string }; props: { placeId: string } }> = [];
  const seen = new Set<string>();

  for (const place of places) {
    for (const language of SUPPORTED_LANGUAGES) {
      const slug = chooseSlugForLanguage(place.translations, language, place.canonical_language);
      if (!slug) continue;
      const key = `${language}:${slug}`;
      if (seen.has(key)) continue;
      seen.add(key);
      paths.push({
        params: { lang: language, placeSlug: slug },
        props: { placeId: place.place_id },
      });
    }
  }

  return paths;
}

const lang = Astro.params.lang || '';
if (!isSupportedLanguage(lang)) {
  throw new Error(`Unsupported language: ${lang}`);
}

const [allPlaces, allPosts] = await Promise.all([getAtlasPlaces(), getBlogPosts()]);
const place = allPlaces.find((entry) => entry.place_id === Astro.props.placeId) as AtlasPlace | undefined;
if (!place) {
  throw new Error(`Atlas place not found for place_id=${Astro.props.placeId}`);
}

const ui = getUiMessages(lang);
const runtimeMode = Astro.url.searchParams.get('translate') === '1';
const placeMap = new Map(allPlaces.map((entry) => [entry.place_id, entry]));
const labelMapping = place.country_profile?.label_mapping || place.country_profile?.level_labels || {};
const levelLabel = (placeType?: string | null) =>
  placeType ? labelMapping[placeType] || placeType : translate(ui, 'atlas.meta.notAvailable');

const normalizeState = (state: string | null | undefined): 'complete' | 'draft' | 'missing' => {
  if (state === 'complete' || state === 'draft' || state === 'missing') return state;
  return 'missing';
};

const stateLabel = (state: 'complete' | 'draft' | 'missing') =>
  translate(ui, `atlas.list.states.${state}`, {}, state);

const stateVariant = (state: 'complete' | 'draft' | 'missing'): 'success' | 'warning' | 'danger' => {
  if (state === 'complete') return 'success';
  if (state === 'draft') return 'warning';
  return 'danger';
};

const mapPlaceLink = (entry: AtlasPlace) => {
  const translated = resolveTranslation(entry.translations, lang, entry.canonical_language);
  const requested = translated.requested;
  const complete = translated.complete;
  const output = translated.output;
  const slug = requested?.status === 'complete' && requested.slug ? requested.slug : complete?.slug;

  if (!output || !slug) return null;

  const stateKey = normalizeState(requested?.status || 'missing');

  return {
    place_id: entry.place_id,
    place_type: entry.place_type,
    place_type_label: levelLabel(entry.place_type),
    title: output.title || entry.place_id,
    href: pathForLanguage(lang, `atlas/${slug}`),
    stateKey,
    stateLabel: stateLabel(stateKey),
  };
};

const resolution = resolveTranslation(place.translations, lang, place.canonical_language, runtimeMode);

if (!resolution.output || !resolution.complete) {
  throw new Error(`No complete translation for ${place.place_id}`);
}

const title = resolution.output.seo?.metaTitle || resolution.output.title || place.place_id;
const description = resolution.output.seo?.metaDescription || resolution.output.excerpt || '';
const isMockView = place.mock === true;
const enComplete =
  place.translations.find((translation) => translation.language === DEFAULT_LANGUAGE && translation.status === 'complete') ||
  null;
const canonicalSource = enComplete || resolution.complete;
const canonicalLanguage = enComplete ? DEFAULT_LANGUAGE : place.canonical_language;
const canonicalSlug = canonicalSource?.slug || place.place_id;

const canonicalPath =
  canonicalSource?.canonical_path || pathForLanguage(canonicalLanguage, `atlas/${canonicalSlug}`);

const languagePathMap: Record<string, string> = {};
for (const language of SUPPORTED_LANGUAGES) {
  const slug = chooseSlugForLanguage(place.translations, language, place.canonical_language);
  if (slug) {
    languagePathMap[language] = pathForLanguage(language, `atlas/${slug}`);
  }
}

const languageLinks = buildLanguageLinks(languagePathMap);
const indexableLanguagePathMap = buildIndexableLanguagePathMap(place.translations, 'atlas', isMockView);
if (!isMockView && enComplete?.slug && !indexableLanguagePathMap[DEFAULT_LANGUAGE]) {
  indexableLanguagePathMap[DEFAULT_LANGUAGE] = canonicalPath;
}
const indexableLanguageLinks = Object.fromEntries(
  Object.entries(indexableLanguagePathMap).map(([language, urlPath]) => [language, absoluteUrl(urlPath)])
);
const alternates = toAlternates(indexableLanguageLinks);
const canonical = absoluteUrl(canonicalPath);
const indexGate = resolveIndexGate(isMockView, resolution, lang);
const robots = indexGate.robots;

const parentPlaceId = place.parent_place_id || place.parent?.place_id || null;
const parentPlace = parentPlaceId ? placeMap.get(parentPlaceId) || null : null;
const parentLink = parentPlace ? mapPlaceLink(parentPlace) : null;
const effectiveRegionKey =
  (typeof place.region === 'string' && place.region.trim()) ||
  (Array.isArray(place.region_groups) && place.region_groups.length > 0 ? place.region_groups[0]?.region_key : '') ||
  null;
const latitude = typeof place.lat === 'number' ? place.lat : typeof place.latitude === 'number' ? place.latitude : null;
const longitude = typeof place.lng === 'number' ? place.lng : typeof place.longitude === 'number' ? place.longitude : null;
const coordinatesLabel =
  latitude !== null && longitude !== null ? `${latitude.toFixed(5)}, ${longitude.toFixed(5)}` : null;

const childPlaces = allPlaces.filter(
  (entry) => (entry.parent_place_id || entry.parent?.place_id || null) === place.place_id
);
const childLinks = childPlaces
  .map((entry) => mapPlaceLink(entry))
  .filter((item): item is NonNullable<ReturnType<typeof mapPlaceLink>> => Boolean(item))
  .sort((a, b) => a.title.localeCompare(b.title));
const visibleChildLinks = childLinks.slice(0, 30);
const hiddenChildCount = Math.max(0, childLinks.length - visibleChildLinks.length);

const breadcrumbChain: AtlasPlace[] = [];
const breadcrumbSeen = new Set<string>();
let cursor: AtlasPlace | null = place;

while (cursor && !breadcrumbSeen.has(cursor.place_id)) {
  breadcrumbChain.push(cursor);
  breadcrumbSeen.add(cursor.place_id);
  const nextParentId = cursor.parent_place_id || cursor.parent?.place_id || null;
  cursor = nextParentId ? placeMap.get(nextParentId) || null : null;
}

breadcrumbChain.reverse();
const breadcrumbLinks = breadcrumbChain
  .map((entry) => mapPlaceLink(entry))
  .filter((item): item is NonNullable<ReturnType<typeof mapPlaceLink>> => Boolean(item))
  .map((entry) => ({ title: entry.title, href: entry.href }));

const excludedRelated = new Set([
  place.place_id,
  parentLink?.place_id || null,
  ...childLinks.map((entry) => entry.place_id),
]);

const nearbyLinks = allPlaces
  .filter((entry) => {
    if (excludedRelated.has(entry.place_id)) return false;
    if (entry.country_code !== place.country_code) return false;

    const entryParentId = entry.parent_place_id || entry.parent?.place_id || null;
    if (entryParentId && parentPlaceId && entryParentId === parentPlaceId) return true;
    return entry.place_type === place.place_type;
  })
  .map((entry) => mapPlaceLink(entry))
  .filter((item): item is NonNullable<ReturnType<typeof mapPlaceLink>> => Boolean(item))
  .slice(0, 12);

const relatedBlogLinks = allPosts
  .filter((post) => {
    if (!post.published_on) return false;
    const refs = resolveBlogPlaceRefs(post);
    if (refs.includes(place.place_id)) return true;
    if (!Array.isArray(post.related_places) || post.related_places.length === 0) return false;
    return post.related_places.some((item) => item.place_id === place.place_id);
  })
  .map((post) => {
    const resolved = resolveTranslation(post.translations, lang, post.canonical_language);
    const requested = resolved.requested;
    const complete = resolved.complete;
    if (!resolved.output || !complete?.slug) return null;

    const slug = requested?.status === 'complete' && requested.slug ? requested.slug : complete.slug;
    const statusKey = normalizeState(requested?.status || 'missing');
    return {
      post_id: post.post_id,
      title: resolved.output.title || post.post_id,
      href: pathForLanguage(lang, `blog/${slug}`),
      statusKey,
      statusLabel: stateLabel(statusKey),
      published_on: post.published_on,
    };
  })
  .filter(
    (item): item is { post_id: string; title: string; href: string; statusKey: 'complete' | 'draft' | 'missing'; statusLabel: string; published_on?: string } =>
      Boolean(item)
  )
  .slice(0, 5);

const requestedStateKey = normalizeState(resolution.requested?.status || 'missing');
const requestedStateLabel = stateLabel(requestedStateKey);

const regionLabel = effectiveRegionKey || '—';
const metaLine = `${translate(ui, 'atlas.meta.country')}: ${place.country_code} · ${translate(ui, 'atlas.meta.region')}: ${regionLabel}`;

const placeAny = place as Record<string, unknown>;

const valueFromKeys = (keys: string[]) => {
  for (const key of keys) {
    const value = placeAny[key];
    if (typeof value === 'number') return value;
    if (typeof value === 'string' && value.trim()) return value.trim();
  }
  return null;
};

const populationRaw = valueFromKeys(['population', 'population_total']);
const populationValue =
  typeof populationRaw === 'number' ? new Intl.NumberFormat(lang).format(populationRaw) : populationRaw;

const elevationRaw = valueFromKeys(['elevation_m', 'elevation']);
const elevationValue =
  typeof elevationRaw === 'number'
    ? `${new Intl.NumberFormat(lang).format(elevationRaw)} m`
    : elevationRaw;

const quickFacts = [
  {
    key: 'population',
    label: translate(ui, 'atlas.quickFacts.population'),
    value: populationValue,
  },
  {
    key: 'coordinates',
    label: translate(ui, 'atlas.quickFacts.coordinates'),
    value: coordinatesLabel,
  },
  {
    key: 'timezone',
    label: translate(ui, 'atlas.quickFacts.timezone'),
    value: valueFromKeys(['timezone', 'timezone_name', 'time_zone']),
  },
  {
    key: 'currency',
    label: translate(ui, 'atlas.quickFacts.currency'),
    value: valueFromKeys(['currency', 'currency_code']),
  },
  {
    key: 'language',
    label: translate(ui, 'atlas.quickFacts.language'),
    value: valueFromKeys(['language', 'languages', 'primary_language']),
  },
  {
    key: 'elevation',
    label: translate(ui, 'atlas.quickFacts.elevation'),
    value: elevationValue,
  },
];

const travelCards = [
  {
    key: 'visa',
    title: translate(ui, 'atlas.travelEssentials.visa'),
    description: translate(ui, 'tools.visa.description', {}, 'Entry checklist starter'),
    helper: translate(ui, 'atlas.travelEssentials.helper.noOrigin'),
  },
  {
    key: 'flights',
    title: translate(ui, 'atlas.travelEssentials.flights'),
    description: translate(ui, 'tools.flights.description', {}, 'Route planning cue'),
    helper: translate(ui, 'atlas.travelEssentials.helper.noOrigin'),
  },
  {
    key: 'currency',
    title: translate(ui, 'atlas.travelEssentials.currency'),
    description: translate(ui, 'tools.currency.description', {}, 'Quick FX note'),
    helper: translate(ui, 'atlas.travelEssentials.helper.noOrigin'),
  },
];

const tocSections = [
  { id: 'overview', label: translate(ui, 'atlas.section.overview') },
  { id: 'quick-facts', label: translate(ui, 'atlas.section.quickFacts') },
  { id: 'hierarchy', label: translate(ui, 'atlas.section.hierarchy') },
  { id: 'travel-essentials', label: translate(ui, 'atlas.section.travelEssentials') },
  { id: 'related-posts', label: translate(ui, 'atlas.section.relatedPosts') },
  { id: 'nearby-places', label: translate(ui, 'atlas.section.nearbyPlaces') },
];
---

<MainLayout
  title={title}
  description={description}
  canonical={canonical}
  robots={robots}
  currentLanguage={lang}
  languageLinks={languageLinks}
  alternates={alternates}
  ui={ui}
  showTools={true}
  toolsContext={resolution.output.title}
>
  {isMockView ? <StateBanner status="mock" language={lang} canonicalPath={canonical} ui={ui} /> : null}

  {
    resolution.isRuntime ? (
      <StateBanner status="runtime" language={lang} canonicalPath={canonical} ui={ui} />
    ) : resolution.isFallback ? (
      <StateBanner
        status="fallback"
        language={lang}
        canonicalPath={canonical}
        contentStatus={resolution.requested?.status || 'missing'}
        ui={ui}
      />
    ) : null
  }

  <PlaceHeader
    breadcrumbLabel={translate(ui, 'atlas.links.breadcrumb')}
    breadcrumbs={breadcrumbLinks}
    title={resolution.output.title || place.place_id}
    kindLabel={levelLabel(place.place_type)}
    languageState={requestedStateLabel}
    stateVariant={stateVariant(requestedStateKey)}
    metaLine={metaLine}
    badgeGroupLabel={translate(ui, 'atlas.hierarchy.badgesAria')}
  />

  <QuickFacts sectionId="quick-facts" title={translate(ui, 'atlas.section.quickFacts')} facts={quickFacts} />

  <div class="atlas-detail-layout" data-atlas-detail-layout>
    <div class="atlas-detail-main" data-atlas-detail-main>
      <section id="overview" class="atlas-detail-section" data-atlas-overview>
        <h2 class="atlas-section-title">{translate(ui, 'atlas.section.overview')}</h2>
        <Card class="atlas-overview-card" as="section">
          {resolution.output.excerpt ? <p class="atlas-overview-lead">{resolution.output.excerpt}</p> : null}
          {resolution.output.body ? (
            <article class="prose-body atlas-detail-prose" set:html={resolution.output.body}></article>
          ) : (
            <p>{translate(ui, 'atlas.noBody')}</p>
          )}

          {
            resolution.requested?.status !== 'complete' && !runtimeMode ? (
              <p>
                <a href={`?translate=1`}>{translate(ui, 'actions.previewOnDemand')}</a>
              </p>
            ) : null
          }
        </Card>
      </section>

      <HierarchyNav
        sectionId="hierarchy"
        title={translate(ui, 'atlas.section.hierarchy')}
        parentTitle={translate(ui, 'atlas.links.parent')}
        childrenTitle={translate(ui, 'atlas.links.children')}
        parent={parentLink}
        children={visibleChildLinks}
        noParentTitle={translate(ui, 'atlas.hierarchy.noParent')}
        noParentDescription={translate(ui, 'atlas.links.noParent')}
        noChildrenTitle={translate(ui, 'atlas.hierarchy.noChildren')}
        noChildrenDescription={translate(ui, 'atlas.links.noChildren')}
        hiddenChildrenLabel={
          hiddenChildCount > 0 ? translate(ui, 'atlas.hierarchy.moreChildren', { count: hiddenChildCount }) : null
        }
        badgeAriaLabel={translate(ui, 'atlas.hierarchy.badgesAria')}
      />

      <AdSlot {...{ slot: 'atlas_incontent' }} class="atlas-incontent-ad" testId="ad-slot-atlas-incontent" />

      <TravelEssentials
        sectionId="travel-essentials"
        title={translate(ui, 'atlas.section.travelEssentials')}
        cards={travelCards}
        comingSoonLabel={translate(ui, 'atlas.travelEssentials.comingSoon')}
      />

      <RelatedPosts
        sectionId="related-posts"
        title={translate(ui, 'atlas.section.relatedPosts')}
        posts={relatedBlogLinks}
        emptyTitle={translate(ui, 'atlas.relatedPosts.empty')}
        emptyDescription={translate(ui, 'atlas.links.noRelatedBlog')}
      />

      <section id="nearby-places" class="atlas-detail-section" data-atlas-nearby-places>
        <h2 class="atlas-section-title">{translate(ui, 'atlas.section.nearbyPlaces')}</h2>

        {
          nearbyLinks.length ? (
            <Card class="atlas-nearby-card">
              <ul class="atlas-link-list atlas-nearby-list">
                {
                  nearbyLinks.map((entry) => (
                    <li>
                      <a class="atlas-link-card-title" href={entry.href} title={entry.title}>
                        {entry.title}
                      </a>
                      <BadgeGroup class="atlas-link-card-badges" ariaLabel={translate(ui, 'atlas.hierarchy.badgesAria')}>
                        <Badge variant={stateVariant(entry.stateKey)} class="atlas-state-badge">
                          {entry.stateLabel}
                        </Badge>
                        <Badge variant="info" class="atlas-kind-badge">
                          {entry.place_type_label}
                        </Badge>
                      </BadgeGroup>
                    </li>
                  ))
                }
              </ul>
            </Card>
          ) : (
            <EmptyState
              title={translate(ui, 'atlas.section.nearbyPlaces')}
              description={translate(ui, 'atlas.links.noRelated')}
              icon="MapPinOff"
            />
          )
        }
      </section>
    </div>

    <div class="atlas-detail-toc-rail">
      <MiniTOC
        title={translate(ui, 'atlas.toc.title')}
        ariaLabel={translate(ui, 'atlas.toc.aria')}
        sections={tocSections}
      />
    </div>
  </div>
</MainLayout>
